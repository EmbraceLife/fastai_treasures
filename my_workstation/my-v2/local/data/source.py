#AUTOGENERATED! DO NOT EDIT! File to edit: dev/05_data_source.ipynb (unless otherwise specified).

__all__ = ['LambdaItem', 'DataSource', 'DsrcSubset']

from ..imports import *
from ..test import *
from ..core import *
from .core import *
from .pipeline import *
from ..notebook.showdoc import show_doc

class LambdaItem:
    "An item that calls `f` on `show`"
    def __init__(self,f): self.f=f
    def show(self,o,**kwargs): return self.f(o,**kwargs)

@docs
class DataSource(TfmdList):
    "Applies a `tfm` to filtered subsets of `items`"
    def __init__(self, items, tfm=noop, filts=None, do_setup=True):
        if filts is None: filts = [range_of(items)]
        self.filts = L(mask2idxs(filt) for filt in filts)
        # Create map from item id to filter id
        assert all_disjoint(self.filts)
        self.filt_idx = L([None]*len(items))
        for i,f in enumerate(self.filts): self.filt_idx[f] = i
        super().__init__(items, tfm, do_setup=do_setup)

    @property
    def n_subsets(self): return len(self.filts)
    def len(self,filt): return len(self.filts[filt])
    def subset(self, i): return DsrcSubset(self, i)
    def subsets(self): return map(self.subset, range(self.n_subsets))
    def __repr__(self): return '\n'.join(map(str,self.subsets())) + f'\ntfm - {self.tfm}'

    def __getitem__(self, i):
        "Transformed item(s) at `i`, using the appropriate filter"
        its,fts = self.items[i],self.filt_idx[i]
        if is_iter(i): return L(self.tfm(it, filt=f) for it,f in zip(its,fts))
        else: return self.tfm(its, filt=fts)

    @classmethod
    def build(cls, items, tfms=None, filts=None, final_tfms=None):
        "Create `DataSource` from `Pipeline` starting with `TfmOver` of `tfms` then transforms in `final_tfms`"
        return cls(items, TfmOver.piped(tfms, final_tfms), filts=filts)

    _docs = dict(len="`len` of subset `filt`",
                 setup="Transform setup",
                 subset="Filtered `DsrcSubset` `i`",
                 subsets="Iterator for all subsets")

DataSource.train,DataSource.valid = add_props(lambda i,x: x.subset(i), 2)

@docs
class DsrcSubset():
    "A filtered subset of a `DataSource`"
    def __init__(self, dsrc, filt):
        self.dsrc,self.filt,self.filts,self.tfm = dsrc,filt,dsrc.filts[filt],dsrc.tfm
    def __getitem__(self,i): return self.dsrc[self.filts[i]]
    def decode(self, o, **kwargs): return self.dsrc.decode(o, filt=self.filt, **kwargs)
    def decode_batch(self, b, **kwargs): return self.dsrc.decode_batch(b, filt=self.filt, **kwargs)
    def decode_at(self, i, **kwargs): return self.decode(self[i], **kwargs)
    def show     (self, o, **kwargs): return self.dsrc.show(o, filt=self.filt, **kwargs)
    def show_at  (self, i, **kwargs): return self.dsrc.show(self[i], filt=self.filt, **kwargs)
    def __len__(self): return len(self.filts)
    def __eq__(self,b): return all_equal(b,self)
    def __repr__(self): return coll_repr(self)

    _docs = dict(decode="Transform decode",
                 show="Transform show",
                 decode_batch="Transform decode batch",
                 __getitem__="Encoded item(s) at `i`",
                 decode_at="Decoded item at `i`",
                 show_at="Show decoded item at `i`")